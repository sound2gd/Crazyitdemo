## 第六章　面向对象(下)

### 6.1 Java8增强的包装类

JDK1.5之后提供了自动装箱的自动拆箱功能：
- 自动装箱:把一个基本类型的变量赋值给对应的包装类变量
- 自动拆箱:与上相反

基本类型对象和String对象互转的方式有:
1. 包装类的parseXXX(String s)方法
2. 包装类的valueOf()方法转成String或者把基本类型变量和一个""连接

Java7之后为所有的包装类提供了一个静态的compare(xxx val1,xxx val2)方法
可以比较前后两个变量的大小，对于Boolean:true>false

Java8再次增强了包装类,最重要的一个增强就是增加了无符号算数运算
增加了如下方法:
- static String toUnsignedString(int/long i);
- static String toUnsignedString(int/long i,int radix)指定进制转换基本类型为无符号整形对应的字符串
- static xxx parseUnsignedXxx(String s)将指定字符串解析成无符号整数
等等,具体代码参见UnsignedTest.java

### 6.2 处理对象
#### 6.2.1　打印对象
打印一个对象的时候，实际上是调用了它的toString()方法.
toString方法是Object类的方法，由于所有类都是Object类的子类，所以所有类都继承了该方法
Object类提供的toString()方法总是返回该对象实现类的"类名+@+十六进制的HashCode"

#### 6.2.2 ==和equals()方法
判断两个变量是否相等有两种方式:
- ==操作符
- equals()方法

它们之间的区别在于：**当比较引用变量时，==操作符需要两个变量指向同一个**
**对象的时候，才会返回true**.

正确的重写equals要满足以下要求:
1. 自反性
2. 对称性
3. 传递性
4. 一致性
5. 对于不是null的x,x.equals(null)一定返回false

对于instanceof操作符而言，只有前面的对象是后面类的实例或者其子类的实例的是时候才返回true

### 6.3 类成员
Java类里只能包含　成员变量，方法，构造器，初始化块，内部类(包括接口，枚举)5种成员。
#### 6.3.1 理解类成员
static修饰的成员属于类成员，不属于实例对象。
类变量属于整个类，当系统第一次准备使用该类时，系统会为该类分配内存空间，类变量开始生效
知道类被卸载，该类变量占有的内存才会被系统的垃圾回收机制回收。

类变量既可以通过类的访问，也可以通过类的对象来访问。
对于static关键字而言，有一条重要的规则:
**类成员(包括方法，初始化块，内部类和枚举类)不能访问实例成员(包括成员变量，方法，初始化块，内部类和枚举类)**　　
#### 6.3.2 单例类
在某些时候，允许其他类自由创建某类的实例没有任何意义，比如系统可能只有一个窗口管理器。
如果一个类始终只能创建一个实例，那么这个类称为单例类
### 6.4 final修饰符
final关键字用于修饰类，方法，变量，用于表示它修饰的类，方法，变量不可改变
final变量一旦获得了初始值，就不可再改变
#### 6.4.1 final成员变量
final修饰的成员变量必须由程序员显示的指定初始值。
***
对于final类变量，必须在**静态初始化块**或者**声明该变量**的时候初始化
对于final实例变量,必须在**构造器**，**非静态初始化块**或者**声明该变量**的时候初始化

#### 6.4.2 final局部变量
不能对final修饰的形参进行赋值。

``` java
public void test(final int a){
	//不能对final形参赋值，以下语句报错
	a = 6;
}
```

#### 6.4.3 final修饰基本类型变量和引用类型变量的区别
当使用final修饰基本类型变量时，不能对基本类型变量重新赋值
因此基本类型变量不能改变

当使用final修饰引用变量时，由于引用变量存放的是所指向对象的地址，所以
该地址不可变，也就是说始终指向同一个对象，但是这个对象可改变。
#### 6.4.4 可执行"宏替换"的final变量
对于一个变量来说，只要满足以下三个条件，就可以当成直接量使用:
- 使用final修饰符修饰
- 在定义该变量的时候指定了初始值
- 该初始值在编译的时候就可以确定下来

那么编译器会被程序中所有用到了该变量的地方直接替换成该变量的值

#### 6.4.5 final方法

final方法不可被重写
#### 6.4.6 final类
final类不可被继承
#### 6.4.7 不可变类
不可变类是创建该类的实例后，该类的**实例变量**是不可变的。
***
	
	设计不可变类时候，要警惕引用类型的实例变量

#### 6.4.8 缓存实例的不可变类

不可变类的实例状态不可以改变，可以方便的被多个对象共享。
如果多个程序经常需要使用相同的不可变类，则应该考虑缓存该不可变类。

***
	jdk中的包装类，如Integer，就是不可变类。
	使用的基本类型的数据，会被其缓存。
	所以尽量不要让它自动拆箱，而是使用Integer.valueOf方法，这样使用的时候缓存的对象。
	
### 6.5 抽象类
#### 6.5.1 抽象方法和抽象类
抽象方法是只有方法签名，没有方法实现的方法。
有抽象方法的类只能是抽象类。

*** 
	抽象类不能实例化
	final和abstract不能同时使用
	
#### 6.5.2 抽象类的作用
模板模式设计:编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给
其子类实现。
### 6.6 Java8改进的接口
Java8对接口进行了改进，允许在接口中定义默认方法，默认方法可以提供方法实现。
#### 6.6.1 接口的概念
接口是通用设计，体现的是规范和实现分离的设计。
这样的好处是：让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。
#### 6.6.2 Java8中接口的定义
``` java
interface 接口名{
	常量定义;
	抽象方法定义;
	内部类，接口，枚举定义;
	默认方法或者类方法定义;	
}
```
系统会自动为每个方法增加public abstract修饰符

#### 6.6.3 接口的继承
接口完全支持多继承。
#### 6.6.4　使用接口
接口有如下用途:
- 定义变量
- 调用接口中定义的常量
- 被其他类实现

可以声明一个引用类型的变量，然后使用多态

#### 6.6.5 接口和抽象类
接口体现的是一种规范。接口是多个模块之间耦合的标准，当在多个应用程序之间使用接口
时，接口是多个应用程序的通信标准。
### 6.7 内部类
内部类主要有如下作用:
- 内部类提供了更好的封装
- 内部类成员可以直接访问外部类的私有数据
- 匿名内部类适合用于创建那些仅需要一次使用的类

#### 6.7.1 非静态内部类
由于内部类上一层次是类，所以有４种访问权限：private,default,protected,public
***
在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用(当调用非静态内部类的实例方法时，
必须有一个非静态内部类实例，非静态内部类实例必须继承在外部类实例里)。

如果外部类成员变量，内部类成员变量与内部类的方法的局部变量重名，则可以
通过使用this，外部类类名.this作为限定区分

Java不允许在非静态内部类里定义静态成员
#### 6.7.2 静态内部类
如果使用static修饰内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象
***

静态内部类是寄生在外部类本身。

#### 6.7.3 使用内部类
非静态内部类的构造器必须通过外部类对象来调用
内部类无法被子类重写
#### 6.7.4 局部内部类
没什么用
#### 6.7.5 Java8改进的匿名内部类
匿名内部类适合创建那种只需要一次使用的类:
- 匿名内部类不能是抽象类
- 匿名内部类不能定义构造器

### 6.8 Java8新增的Lambda表达式
(参数) -> {代码块}

### 6.9 枚举类
#### 6.9.1 枚举类之前如何定义
#### 6.9.2 枚举类概念
#### 6.9.3　枚举类的成员变量，方法和构造器
#### 6.9.4 实现接口的枚举类
#### 6.9.5 包含抽象方法的枚举类
### 6.10 对象与垃圾回收








