## 第六章　面向对象(下)

### 6.1 Java8增强的包装类

JDK1.5之后提供了自动装箱的自动拆箱功能：
- 自动装箱:把一个基本类型的变量赋值给对应的包装类变量
- 自动拆箱:与上相反

基本类型对象和String对象互转的方式有:
1. 包装类的parseXXX(String s)方法
2. 包装类的valueOf()方法转成String或者把基本类型变量和一个""连接

Java7之后为所有的包装类提供了一个静态的compare(xxx val1,xxx val2)方法
可以比较前后两个变量的大小，对于Boolean:true>false

Java8再次增强了包装类,最重要的一个增强就是增加了无符号算数运算
增加了如下方法:
- static String toUnsignedString(int/long i);
- static String toUnsignedString(int/long i,int radix)指定进制转换基本类型为无符号整形对应的字符串
- static xxx parseUnsignedXxx(String s)将指定字符串解析成无符号整数
等等,具体代码参见UnsignedTest.java

### 6.2 处理对象
#### 6.2.1　打印对象
打印一个对象的时候，实际上是调用了它的toString()方法.
toString方法是Object类的方法，由于所有类都是Object类的子类，所以所有类都继承了该方法
Object类提供的toString()方法总是返回该对象实现类的"类名+@+十六进制的HashCode"

#### 6.2.2 ==和equals()方法
判断两个变量是否相等有两种方式:
- ==操作符
- equals()方法

它们之间的区别在于：**当比较引用变量时，==操作符需要两个变量指向同一个**
**对象的时候，才会返回true**.

正确的重写equals要满足以下要求:
1. 自反性
2. 对称性
3. 传递性
4. 一致性
5. 对于不是null的x,x.equals(null)一定返回false

对于instanceof操作符而言，只有前面的对象是后面类的实例或者其子类的实例的是时候才返回true

### 6.3 类成员
Java类里只能包含　成员变量，方法，构造器，初始化块，内部类(包括接口，枚举)5种成员。
#### 6.3.1 理解类成员
static修饰的成员属于类成员，不属于实例对象。
类变量属于整个类，当系统第一次准备使用该类时，系统会为该类分配内存空间，类变量开始生效
知道类被卸载，该类变量占有的内存才会被系统的垃圾回收机制回收。

类变量既可以通过类的访问，也可以通过类的对象来访问。
对于static关键字而言，有一条重要的规则:
**类成员(包括方法，初始化块，内部类和枚举类)不能访问实例成员(包括成员变量，方法，初始化块，内部类和枚举类)**　　
#### 6.3.2 单例类
在某些时候，允许其他类自由创建某类的实例没有任何意义，比如系统可能只有一个窗口管理器。
如果一个类始终只能创建一个实例，那么这个类称为单例类
### 6.4 final修饰符
final关键字用于修饰类，方法，变量，用于表示它修饰的类，方法，变量不可改变
final变量一旦获得了初始值，就不可再改变
#### 6.4.1 final成员变量
final修饰的成员变量必须由程序员显示的指定初始值。
***
对于final类变量，必须在**静态初始化块**或者**声明该变量**的时候初始化
对于final实例变量,必须在**构造器**，**非静态初始化块**或者**声明该变量**的时候初始化

#### 6.4.2 final局部变量
不能对final修饰的形参进行赋值。

``` java
public void test(final int a){
	//不能对final形参赋值，以下语句报错
	a = 6;
}
```

#### 6.4.3 final修饰基本类型变量和引用类型变量的区别
当使用final修饰基本类型变量时，不能对基本类型变量重新赋值
因此基本类型变量不能改变

当使用final修饰引用变量时，由于引用变量存放的是所指向对象的地址，所以
该地址不可变，也就是说始终指向同一个对象，但是这个对象可改变。
#### 6.4.4 可执行"宏替换"的final变量
对于一个变量来说，只要满足以下三个条件，就可以当成直接量使用:
- 使用final修饰符修饰
- 在定义该变量的时候指定了初始值
- 该初始值在编译的时候就可以确定下来

那么编译器会被程序中所有用到了该变量的地方直接替换成该变量的值

#### 6.4.5 final方法

final方法不可被重写
#### 6.4.6 final类
final类不可被继承
#### 6.4.7 不可变类
不可变类是创建该类的实例后，该类的**实例变量**是不可变的。
***
	
	设计不可变类时候，要警惕引用类型的实例变量

#### 6.4.8 缓存实例的不可变类

不可变类的实例状态不可以改变，可以方便的被多个对象共享。
如果多个程序经常需要使用相同的不可变类，则应该考虑缓存该不可变类。

***
	jdk中的包装类，如Integer，就是不可变类。
	使用的基本类型的数据，会被其缓存。
	所以尽量不要让它自动拆箱，而是使用Integer.valueOf方法，这样使用的时候缓存的对象。
	
### 6.5 抽象类
#### 6.5.1 抽象方法和抽象类
#### 6.5.2 抽象类的作用
### 6.6 Java8改进的接口
#### 6.6.1 接口的概念
#### 6.6.2 Java8中接口的定义
#### 6.6.3 接口的继承
#### 6.6.4　使用接口
#### 6.6.5 接口和抽象类
### 6.7 内部类
#### 6.7.1 非静态内部类
#### 6.7.2 静态内部类
#### 6.7.3 使用内部类
#### 6.7.4 局部内部类
#### 6.7.5 Java8改进的匿名内部类
### 6.8 Java8新增的Lambda表达式
### 6.9 枚举类
#### 6.9.1 枚举类之前如何定义
#### 6.9.2 枚举类概念
#### 6.9.3　枚举类的成员变量，方法和构造器
#### 6.9.4 实现接口的枚举类
#### 6.9.5 包含抽象方法的枚举类
### 6.10 对象与垃圾回收








