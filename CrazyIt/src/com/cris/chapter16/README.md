## 第十六章 Java中的多线程

本章共有6个知识点：

1. 多线程的基本概念(类结构，生命周期)
2. 多线程的启动方式(Runnable,Future,Thread)
3. 多线程的控制方式与同步
4. 多线程的通信(传统，Condition,BlockingQueue)
5. 线程池(ExecutorService)
6. 线程安全相关的工具(ThreadLocal,Collections.synchrizeXXX,java.util.concurrent)

### 一，多线程的基本概念
#### 1.1 进程和线程
首先看看什么是进程：

进程是操作系统层面的概念，当一个程序进入内存时，就变成了一个进程。进程是处于运行状态中的程序，并且具有一定的独立功能。
进程是**操作系统**进行资源分配和调度的一个独立单位。

进程有如下三个特征:

1. 独立性:进程是系统中独立存在的实体，可以拥有自己的独立的资源。每一个进程都拥有自己私有的地址空间
2. 动态性:进程具有自己的生命周期和各种不同的状态
3. 并发性:多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响

现在计算机大部分都支持**多进程的并发**，你可以一边听歌一边用浏览器看网页就是例子。

**多线程**扩展了多进程的概念，使得同一个进程可以同时并发处理任务。线程(Thread)也称为**轻量级进程(LightWeight Process)**
线程是进程的执行单元，线程在进程程序中是独立的，并发的执行流。每个线程也是相互独立的。

线程是进程的组成部分，一个进程可以有多个线程，但是一个线程只能有一个父进程。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，
但是不拥有系统资源，它与父进程的其他线程共享该进程锁拥有的全部资源。

一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行

#### 1.2 多线程的优势
线程在程序中是独立的，并发的执行流。与分隔的进程相比，进程中线程的的隔离程度要小很多，它们共享内存，文件句柄和其他每个进程应有的状态

线程比进程具有更高的性能，这是因为多个线程共享同一个虚拟空间。
线程共享的环境包括:**进程代码段，进程的共有数据**等。

实际应用中，多线程十分有用，一个浏览器必须能下载多个图片，一个web服务器必须能同时响应多个用户的请求。

#### 1.3 多线程的生命周期
在Java中，线程的生命周期有如下几种:

1. New新建
2. Runnable 就绪
3. Running 运行
4. Blocked 阻塞
5. Dead 死亡

当一个线程新建之后，就变成New状态，当调用start()方法之后，就变成了Runnable状态，JVM
会为其创建方法调用栈和程序计数器。

***
在单核cpu的机器上，任何时刻都只有一个线程得到执行。
在多核cpu上，将会有多个线程并行（同时）执行。当线程数大于处理器数时候，依然会存在多个线程在同一cpu轮换的情况。
***

当发生如下情况时，会使线程阻塞：

1. 线程调用sleep方法主动放弃所占用的cpu资源
2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
3. 线程正试图获得一个同步监视器(synchonized 修饰的对象的监视器)，但是该对象正在被其他线程持有。
4. 线程正在等待某个通知(notify)
5. 程序调用了线程的suspend方法将该线程挂起。**这方法容器导致死锁！尽量避免使用**


当发生如下情况时，会使线程恢复到就绪状态Runnable:

1. 程序从sleep恢复
2. 阻塞式IO返回了结果
3. 成功获得试图获得的同步监视器锁
4. 程序正在等待一个通知，其他线程发出了一个通知
5. 处于挂起状态的线程被调用了resume()方法

程序从Running到Runnable只要调用yield方法就可以放弃cpu资源

线程死亡一般有如下3种方式:

1. 线程完成了本身的任务
2. 线程抛出了一个异常UncaughtException或者错误Error
3. 直接调用该线程的stop()方法来结束该线程,**不推荐使用！容易导致死锁！**

一图解千言（图来自博客，版权归原作者所有,侵删）:

![Java多线程状态变化图](http://images.cnitblog.com/blog/325852/201302/20011044-cffc02c7b77b49dfaf42ed611c8b1cf8.png)

### 二，线程的创建和启动
Java使用Thread类代表线程，所有的线程对象都是Thread类或者其子类的实例。
Java实现多线程有3个方法:

1. 继承Thread，重写run方法
2. 实现Runnable,重写run方法
3. 实现Callable,重写call方法

#### 2.1 继承Thread类创建线程类
通过继承Thread类来启动多线的步骤如下:

1. 定义Thread类的子类，重写run方法
2. 创建该子类的实例，这样就得到了线程对象(New状态)
3. 调用线程对象的start方法来启动线程


**通过继承Thread类创建线程类时，多个线程之间无法共享线程类的实例变量**

#### 2.2 实现Runnable接口创建线程类
通过实现Runnabel接口创建线程类的步骤如下:

1. 实现java.lang.Runnable接口，重写run方法
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象,**该Thread对象才是真正的线程对象**


采用Runnable接口的方式创建的线程可以共享线程类的实例变量。因为在这种方式下，程序锁创建的Runnable对象只是Thread类的target
而多个线程可以共享同一个target,所以多个线程可以共享同一个线程类(实际上应该线程的target类)的实例变量

#### 2.3 实现Callable和Future接口创建线程类

使用Callable和Future创建线程的方法如下:

1. 创建Callable接口的实现类，并实现call方法
2. 创建FutureTask对象来包装Callable对象，该FutureTask封装了该Callable对象的call方法的返回值
3. 使用FutureTask对象作为Thread对象的target创建并启动新线程
4. 调用FutureTask的get方法来获得子线程执行结束后的返回值

#### 2.4 创建线程的3种方式的对比

采用Runnable和Callable实现多线程的优缺点如下:

- 线程只是实现了Runnable接口或者Callable接口，还可以继承其他类
- 多个线程共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况
- 劣势是:变成稍复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法

使用继承Thread类的方式来创建多线程的优缺点:

- 劣势是:已经继承了Thread类，不能继承其他的类
- 优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread方法，直接使用this

### 三，控制线程和同步

控制线程的执行有下面的方法:

1. join
2. sleep
3. 设置Deamon
4. 改变优先级
5. yield

Thread提供了让一个线程等待另一个线程完成的方法--join方法。
join方法通常由使用线程的程序调用，以将大问题分成许多小问题。每个小问题分配一个线程，当所有的小问题都得到
解决之后，再调用主线程来进行进一步的操作。


有一种线程，它是后台运行的，任务是为其他的线程提供服务，这种线程称为"后台线程(Deamon Thread)"，又称为
守护线程或者精灵线程。

后台线程有个特征，当前台线程死亡，它也会死亡。
前台线程创建的默认就是前台线程，后台线程创建的默认就是后台线程

线程可以让当前正在执行的线程暂停，但是不会阻塞该线程。只是让当前线程暂停一下，让系统线程调度器重新调度一下

每个线程都有一个优先级(1~10)，优先级高的线程获得较多的执行机会。每个线程默认的优先级都和其父线程相同
优先级级别需要操作系统支持，尽量避免直接为线程指定优先级。


***
线程同步有如下方法:

1. synchronized修饰的变量，方法，代码块
2. 使用java.util.concurrent.Lock

线程会在如下情况下释放同步监视器的锁定:

1. 当前线程的同步方法，同步代码块执行结束，当前线程立刻释放同步锁
2. 当前线程在代码块里遇到了break,return终止了该代码块
3. 当前线程在同步代码块，同步方法中出现了未处理的Error,Exception
4. 在执行同步代码块的时候，程序执行了同步监视器对象的wait()方法，当前线程暂停，并释放同步代码块


同步锁一般使用ReentrantLock（可重入锁）.某些锁允许对共享资源并发访问，如ReadWriteLock(读写锁)

当两个线程相互等待对方释放同步监视器锁的时候就会发生死锁。

### 四，线程间通信

线程间通信的方式主要有4种:

1. 传统的通信方式(wait,notify,notifyAll)
2. 使用java.util.Condition(一般配合Lock使用)
3. 使用BlockingQueue
4. 使用PipeXXXStream







